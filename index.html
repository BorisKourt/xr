<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - scenes transition</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
    <!--script src="build/webxr-polyfill.js" type="text/javascript" charset="utf-8"></script-->
    <script src="build/three.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="jsm/utils/BufferGeometryUtils.js" type="text/javascript" charset="utf-8"></script>
    <script src="jsm/vr/WebVR.js" type="text/javascript" charset="utf-8"></script>
	</head>
	<body>
    <script type="text/javascript">

      var camera, scene, renderer, container, textureEquirec, equirectMaterial;
      var canvas2, ctx;

      var controller1, controller2;
			var raycaster, intersected = [];
			var tempMatrix = new THREE.Matrix4();
			var group;
      var cubeCamera, cubeCameraB;
      var material;
      var count = 0;

			init();
			animate();

			function init() {

        canvas2 = document.createElement('canvas');

        if (canvas2.getContext) {
          ctx = canvas2.getContext('2d', { antialias: false, alpha: false });
          canvas2.width = 4096;
          canvas2.height = 2048;
          canvas2.style.position = "absolute";

          ctx.fillStyle = "rgba(200, 200, 0, 0.5)";
          ctx.fillRect(0, 0, 4096, 2048);

          //Loading of the home test image - img1
          var img1 = new Image();

          //drawing of the test image - img1
          img1.onload = function () {
            //draw background image
            ctx.drawImage(img1, 0, 0);
            //draw a box over the top
            ctx.fillStyle = "rgba(200, 0, 0, 0.5)";
            ctx.fillRect(0, 0, 500, 500);

          };

          img1.src = 'images/frans_widerberg_1572276471.jpg';
        }
				document.body.appendChild( canvas2 );

        container = document.createElement( 'div' );
				document.body.appendChild( container );

        var canvas = document.createElement( 'canvas' );
        canvas.style.position = "absolute";
				var context = canvas.getContext( 'webgl2', { antialias: false, alpha: false } );
				renderer = new THREE.WebGLRenderer( { canvas: canvas, context: context } );

				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.vr.enabled = true;
        container.appendChild( renderer.domElement );

        textureEquirec = new THREE.CanvasTexture(canvas2);
        textureEquirec.mapping = THREE.EquirectangularReflectionMapping;
        textureEquirec.magFilter = THREE.LinearFilter;
        textureEquirec.minFilter = THREE.NearestFilter;
        textureEquirec.needsUpdate = true;

        var equirectShader = THREE.ShaderLib[ "equirect" ];

        var equirectMaterial = new THREE.ShaderMaterial( {
          fragmentShader: equirectShader.fragmentShader,
          vertexShader: equirectShader.vertexShader,
          uniforms: equirectShader.uniforms,
          depthWrite: true,
          side: THREE.BackSide
        } );

        equirectMaterial.uniforms[ "tEquirect" ].value = textureEquirec;

        Object.defineProperty( equirectMaterial, 'map', {
          get: function () {

            return this.uniforms.tEquirect.value;

          }
        });
        //equirectMaterial = new THREE.MeshBasicMaterial( { map: textureEquirec } );

        var geometry2 = new THREE.SphereBufferGeometry( 100, 60, 40 );
				// invert the geometry on the x-axis so that all of the faces point inward
				//geometry2.scale( - 1, 1, 1 );

        cubeMesh = new THREE.Mesh( geometry2, equirectMaterial );
        cubeMesh.material = equirectMaterial;
        cubeMesh.visible = true;

				scene = new THREE.Scene();
        scene.add(cubeMesh);

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 200 );

				var geometry = new THREE.TorusKnotBufferGeometry( 0.4, 0.15, 150, 20 );
				var material = new THREE.MeshStandardMaterial(
        { roughness: 0.05,
          metalness: 0.9,
          envMap: textureEquirec
          } );
				var mesh = new THREE.Mesh( geometry, material );
				mesh.castShadow = true;
        mesh.receiveShadow = true;
				mesh.position.y = 0.75;
				mesh.position.z = - 2;
				scene.add( mesh );

				var geometry = new THREE.BoxBufferGeometry( 3, 0.01, 3 );
				var material = new THREE.MeshStandardMaterial(
        { roughness: 0.05,
          metalness: 0.9,
          envMap: textureEquirec
          } );
				var mesh = new THREE.Mesh( geometry, material );
				mesh.castShadow = true;
				mesh.position.y = -1.5;
				mesh.position.z = 1;
        mesh.receiveShadow = true;
				scene.add( mesh );

				var light = new THREE.DirectionalLight( 0x666666 );
				light.position.set( - 1, 1.5, - 1.5 );
				light.castShadow = true;
				light.shadow.camera.zoom = 4;
				scene.add( light );
				light.target.position.set( 0, 0, - 2 );
				scene.add( light.target );

				group = new THREE.Group();
				scene.add( group );

				var geometries = [
					new THREE.BoxBufferGeometry( 0.2, 0.2, 0.2 ),
					new THREE.ConeBufferGeometry( 0.2, 0.2, 64 ),
					new THREE.CylinderBufferGeometry( 0.2, 0.2, 0.2, 64 ),
					new THREE.IcosahedronBufferGeometry( 0.2, 3 ),
					new THREE.TorusBufferGeometry( 0.2, 0.04, 64, 32 )
				];

				for ( var i = 0; i < 50; i ++ ) {

					var geometry = geometries[ Math.floor( Math.random() * geometries.length ) ];
          var material = new THREE.MeshStandardMaterial(
            { roughness: 0.1,
              metalness: 0.9,
              envMap: textureEquirec
              } );

					var object = new THREE.Mesh( geometry, material );

					object.position.x = Math.random() * 4 - 2;
					object.position.y = Math.random() * 2;
					object.position.z = Math.random() * 4 - 2;

					object.rotation.x = Math.random() * 2 * Math.PI;
					object.rotation.y = Math.random() * 2 * Math.PI;
					object.rotation.z = Math.random() * 2 * Math.PI;

					object.scale.setScalar( Math.random() + 0.5 );

					object.castShadow = true;
					object.receiveShadow = true;

					group.add( object );

				}

        /*
				// var helper = new CameraHelper( light.shadow.camera );
				// scene.add( helper );

				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1.5, - 2.5 );
				light.castShadow = true;
				light.shadow.camera.zoom = 4;
				scene.add( light );
				light.target.position.set( 0, 0, - 2 );
				scene.add( light.target );
        */

				// var helper = new CameraHelper( light.shadow.camera );
				// scene.add( helper );



				document.body.appendChild( THREE.WEBVR.createButton( renderer ) );


				// controllers

				controller1 = renderer.vr.getController( 0 );
				controller1.addEventListener( 'selectstart', onSelectStart );
				controller1.addEventListener( 'selectend', onSelectEnd );
				scene.add( controller1 );

				controller2 = renderer.vr.getController( 1 );
				controller2.addEventListener( 'selectstart', onSelectStart );
				controller2.addEventListener( 'selectend', onSelectEnd );
				scene.add( controller2 );

        				var geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );

				var line = new THREE.Line( geometry );
				line.name = 'line';
				line.scale.z = 5;

				controller1.add( line.clone() );
				controller2.add( line.clone() );

				raycaster = new THREE.Raycaster();

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}


      			function onSelectStart( event ) {

				var controller = event.target;

				var intersections = getIntersections( controller );

				if ( intersections.length > 0 ) {

					var intersection = intersections[ 0 ];

					tempMatrix.getInverse( controller.matrixWorld );

					var object = intersection.object;
					object.matrix.premultiply( tempMatrix );
					object.matrix.decompose( object.position, object.quaternion, object.scale );
					object.material.emissive.b = 1;
					controller.add( object );

					controller.userData.selected = object;

				}

			}

			function onSelectEnd( event ) {

				var controller = event.target;

				if ( controller.userData.selected !== undefined ) {

					var object = controller.userData.selected;
					object.matrix.premultiply( controller.matrixWorld );
					object.matrix.decompose( object.position, object.quaternion, object.scale );
					object.material.emissive.b = 0;
					group.add( object );

					controller.userData.selected = undefined;

				}


			}



			function getIntersections( controller ) {

				tempMatrix.identity().extractRotation( controller.matrixWorld );

				raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
				raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

				return raycaster.intersectObjects( group.children );

			}

			function intersectObjects( controller ) {

				// Do not highlight when already selected

				if ( controller.userData.selected !== undefined ) return;

				var line = controller.getObjectByName( 'line' );
				var intersections = getIntersections( controller );

				if ( intersections.length > 0 ) {

					var intersection = intersections[ 0 ];

					var object = intersection.object;
					object.material.emissive.r = 1;
					intersected.push( object );

					line.scale.z = intersection.distance;

				} else {

					line.scale.z = 5;

				}

			}

			function cleanIntersected() {

				while ( intersected.length ) {

					var object = intersected.pop();
					object.material.emissive.r = 0;

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				renderer.setAnimationLoop( render );

			}

			function render() {

				cleanIntersected();

				intersectObjects( controller1 );
				intersectObjects( controller2 );

				var time = performance.now() * 0.0001;


        ctx.fillRect((4096 * time) % 4096, (2048 * time) % 2048, 50, 50);
        textureEquirec.needsUpdate = true;

				renderer.render( scene, camera );

			}

		</script>

	</body>

</html>
